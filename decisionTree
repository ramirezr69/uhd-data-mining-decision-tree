import math
import sys
import os
from collections import Counter

print("Programming Assignment 2")
'''
Things to Do
Recursively Calling the Formula
Visualizing Decision Tree

'''



# List of Tuples with each element consisting of a dictionary and a boolean value
#[({},bool])]

inputs = [
    ({'level': 'Senior', 'lang': 'Java', 'tweets': 'no', 'phd': 'no'}, False),
    ({'level': 'Senior', 'lang': 'Java', 'tweets': 'no', 'phd': 'yes'}, False),
    ({'level': 'Mid', 'lang': 'Python', 'tweets': 'no', 'phd': 'no'}, True),
    ({'level': 'Junior', 'lang': 'Python', 'tweets': 'no', 'phd': 'no'}, True),
    ({'level': 'Junior', 'lang': 'R', 'tweets': 'yes', 'phd': 'no'}, True),
    ({'level': 'Junior', 'lang': 'R', 'tweets': 'yes', 'phd': 'yes'}, False),
    ({'level': 'Mid', 'lang': 'R', 'tweets': 'yes', 'phd': 'yes'}, True),
    ({'level': 'Senior', 'lang': 'Python', 'tweets': 'no', 'phd': 'no'}, False),
    ({'level': 'Senior', 'lang': 'R', 'tweets': 'yes', 'phd': 'no'}, True),
    ({'level': 'Junior', 'lang': 'Python', 'tweets': 'yes', 'phd': 'no'}, True),
    ({'level': 'Senior', 'lang': 'Python', 'tweets': 'yes', 'phd': 'yes'}, True),
    ({'level': 'Mid', 'lang': 'Python', 'tweets': 'no', 'phd': 'yes'}, True),
    ({'level': 'Mid', 'lang': 'Java', 'tweets': 'yes', 'phd': 'no'}, True),
    ({'level': 'Junior', 'lang': 'Python', 'tweets': 'no', 'phd': 'yes'}, False)
]

decisionTree = []

#Class Node to hold all Attributes
class Node:
    value = ""

    def __init__(self,val):
        self.setValue(val)
        self.children = []
        self.attributes = []

    def __str__(self):
        return str(self.value)

    def setValue(self, val):
        self.value = val

    def children(self):
        return self._children

    def attributes(self):
        return self._attributes

    def addChild(self,child):
        self.children.append(child)


    def addAttributes(self, val):
        if not any(val in s for s in self.attributes):
            self.attributes.append(val)
            self.attributes.sort()


def entropy(children, data, targetAttr):
    #children
    #target attribute
    #data
    print('Target Attribute:',targetAttr)
    print(children)


    dataEntropy = 0.0
    trueCounter = 0
    falseCounter = 0


    count = 0
    print('Number of Children:' ,len(children))
    print('Length of Data', len(data))
    while (count < len(children)): #Each child in the node
        print(count, children[count]) #
        for element in data:  # Access each dictionary
            for first in element[:-1]:  # Skips the boolean part of the element Acess each key
                if element[1] == True and first[targetAttr] == children[count]:
                    trueCounter += 1
                elif element[1] == False and first[targetAttr] == children[count]:
                    falseCounter += 1
        class0 = float(trueCounter)
        print("Class 0", trueCounter)
        trueCounter = 0
        class1 = float(falseCounter)
        print("Class 1", falseCounter)
        falseCounter = 0
        total = class0 + class1
        grandTotal = float(total / len(data))
        x = float(class0 / total)
        y = float(class1 / total)
        if x == 0 or y == 0:
            subEntrophy = 0
        else:
            print('(BEFORE) Subentrophy for', ((-x) * math.log(x, 2) - y * math.log(y, 2)))
            subEntrophy = ((-x) * math.log(x, 2) - y * math.log(y, 2)) * grandTotal
        print('Subentrophy for',children[count])
        print(subEntrophy)
        dataEntropy += subEntrophy
        count = count + 1
    print('Total Entrophy:' , dataEntropy)
    return dataEntropy

#Split variables from the data
def splitVariables(data):
    #Get dictionary part of data
    dictionary = []
    for element in data:
        dictionary.append(element[0])

    #Store all the keys in an array
    attr = []
    for key in dictionary[0].keys():
        attr.append(key)



    #Store all keys in a list holding attributes
    counter = 0

    for x in attr:
        sample = Node(attr[counter])
        decisionTree.append(sample)
        counter += 1
    #return decisionTree


    #Add each value to each node
    for x in decisionTree:
        key = str(x)
        print("Hello", key)  # Access all attributes
        for element in data:  # Access each dictionary
            for first in element[:-1]:  # Skips the boolean part of the element Acess each key
                print(key, first[key])  # Print all values of matching key
                x.addChild(first[key])  # Add each Key to all Variables
                x.addAttributes(first[key])  # Add each unique Key to node
                # print('END - Value')
        print('END - Key')

#Determine the best split
def bestSplit(attributes, data):
    entropylist = []
    frequency = 0
    frequencyN = 0
    for x in decisionTree:
        key = str(x)
        print("Hello", key) #Access all attributes
        numberOfChildren = len(x.attributes)
        print(numberOfChildren)
        for element in data: #Access each dictionary
            for first in element[:-1]:  # Skips the boolean part of the element Acess each key
                print(key, first[key])  # Print all values of matching key

                #target = x.children[0]
                #print(target)
                #for child in x.children:

                #Frequency Counter
                if first[key] == 'R':
                    if element[1] == True:
                        frequency += 1
                    else:
                        frequencyN += 1

                #Solve for entrophy
            #print('END - Value')
        minEntropy = entropy(x.attributes, new_input, key)
        entropylist.append(minEntropy)
        print('END - Key')
    print(frequency)
    print(frequencyN)
    print(entropylist)
    print(min(entropylist))
    bestSplitAttribute = entropylist.index(min(entropylist))
    print(bestSplitAttribute)
    return bestSplitAttribute


#Convert a tuple to a list
new_input = list(inputs)
print(new_input)

#Print first element
print(new_input[0])

#Print length of data set
print(len(new_input))

#Divide the data set into two class - Class 0(Yes) and Class 1(No)
goodInterviews = []
badInterviews = []
x = 0
for element in new_input:
    if element[1] == True: #element[1] - True/False
        goodInterviews.append(new_input[x])
        x += 1
    else:
        badInterviews.append(new_input[x])
        x += 1

print("Class 0 - True Count =", len(goodInterviews))
for z in goodInterviews:
    print(z)
print('\n')

print("Class 1 - False Count = ", len(badInterviews))
for z in badInterviews:
    print(z)
print('\n')

#Attributes
#Get Attributes
dictionary = []
for element in new_input:
     dictionary.append(element[0])

for x in dictionary:
    print (x)

#List of Functions to Make
#DETERMINE ATTRIBUTES FUNCTION
#DETERMINE BEST VARIABLE TO SPLIT ON(RECURSIVE)

#Count the attributes
attr = []
for key in dictionary[0].keys():
    attr.append(key)

attributeCount =  len(dictionary[0].keys())
print("Attribute Count = ", attributeCount)
print("Attribute Count = ",len(attr))

#Deleting attributes
#attr.sort()
#del attr[0]

print(attr)

#main
splitVariables(new_input)
splitIndex = bestSplit(decisionTree, new_input)

splitIndex = 3 #Testing

bestSplitStr = str(decisionTree[splitIndex])
print('The best attribute to split is', bestSplitStr)
print(decisionTree[splitIndex].attributes)

#tree = splitVariables(new_input)
print('Attributes:')
for x in decisionTree:
    print(x)


#Print Children
for x in decisionTree:
    print(x.children)
    print(x.attributes)
    print(Counter(x.children))

#How to access all values
A = 'A'
B = 'B'
characterIndex = 67
#Printing the Tree
from graphviz import Digraph

dot = Digraph(comment='The Decision Tree')

#Print the Title Node and the Best Split
dot.node('A', 'Hired?') #65
dot.node('B', bestSplitStr) #66

counter = 0
while counter < len(decisionTree[splitIndex].attributes):
    dot.node(chr(characterIndex), decisionTree[splitIndex].attributes[counter])
    temp = chr(characterIndex)
    dot.edges([B + temp])
    characterIndex += 1
    counter += 1
print(chr(characterIndex))

#Print the children

dot.edges([A + B])

#dot.edge('B', 'L', constraint='false')


from graphviz import Source

src = Source('digraph "the holy hand grenade" { rankdir=LR; 1 -> 2 -> 3 -> lob }')

print(dot.source)
print(ord('A'))
dot.render('test-output/decision-tree.gv', view=True)